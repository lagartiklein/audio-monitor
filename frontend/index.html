<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Monitor - Consola Digital</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ñê‚ñå AUDIO MONITOR ‚ñê‚ñå</h1>
            <div id="device-info" class="device-info">INITIALIZING SYSTEM...</div>
            
            <div class="metrics">
                <div class="metric">
                    <span class="metric-label">LAT:</span>
                    <span id="latency" class="metric-value">--</span>
                    <span>ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">BUF:</span>
                    <span id="buffer" class="metric-value">--</span>
                    <span>%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">NET:</span>
                    <span id="network" class="metric-value">--</span>
                    <span>ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">PROT:</span>
                    <span id="protocol" class="metric-value">WebSocket</span>
                </div>
            </div>
        </header>

        <div id="mixer-console" class="mixer-console">
            <!-- Canales se generan din√°micamente -->
        </div>
    </div>

    <div class="status-bar">
        <div class="status-indicator">
            <div id="status-led" class="status-led"></div>
            <span id="status-text">CONNECTING...</span>
        </div>
        <div id="channel-count">CHANNELS: 0</div>
        <div id="audio-status">AUDIO: INITIALIZING</div>
    </div>

    <div id="warning-message" class="warning-message"></div>

    <script>
        class AudioMonitor {
            constructor() {
                this.socket = null;
                this.audioContext = null;
                this.deviceInfo = null;
                this.activeChannels = new Set();
                this.channelProcessors = {};
                this.audioWorkletReady = false;
                this.protocol = 'websocket';
                this.metrics = {
                    networkLatency: 0,
                    bufferHealth: 100,
                    estimatedLatency: 0,
                    protocol: 'WebSocket',
                    audioLatency: 0,
                    packetLoss: 0,
                    jitter: 0,
                    quality: 'unknown'
                };
                this.connected = false;
                this.audioInitialized = false;
                this.connectionStartTime = Date.now();
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 3;
                this.init();
            }

            async init() {
                console.log('[AudioMonitor] Inicializando solo WebSocket...');
                this.connectionStartTime = Date.now();
                this.updateStatus('CONNECTING...', false);
                this.updateProtocolDisplay();
                await this.connectWebSocket();
                this.startMetricsMonitoring();
                this.setupEventListeners();
            }
            
            async connectWebSocket() {
                console.log('[AudioMonitor] Conectando WebSocket...');
                this.socket = io({
                    transports: ['websocket'],
                    upgrade: false,
                    reconnection: true,
                    reconnectionDelay: 1000,
                    reconnectionAttempts: 5
                });
                this.socket.on('connect', () => {
                    console.log('[Socket] Conectado');
                    this.updateStatus('CONNECTED', true);
                    this.connected = true;
                    document.getElementById('audio-status').textContent = 'AUDIO: READY (WebSocket)';
                    if (this.activeChannels.size > 0) {
                        setTimeout(() => this.updateSubscription(), 500);
                    }
                });
                this.socket.on('disconnect', (reason) => {
                    console.log('[Socket] Desconectado:', reason);
                    this.updateStatus('DISCONNECTED', false);
                    this.connected = false;
                    if (this.reconnectAttempts < this.maxReconnectAttempts) {
                        this.reconnectAttempts++;
                        setTimeout(() => {
                            console.log(`[Socket] Reintento ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
                            this.socket.connect();
                        }, 1000 * this.reconnectAttempts);
                    }
                });
                this.socket.on('device_info', (info) => {
                    this.handleDeviceInfo(info);
                });
                this.socket.on('audio', (data) => {
                    this.handleAudioData(data);
                });
                this.socket.on('pong', (data) => {
                    const latency = Date.now() - data.client_timestamp;
                    this.updateNetworkLatency(latency);
                });
                setInterval(() => {
                    if (this.socket && this.socket.connected) {
                        this.socket.emit('ping', { timestamp: Date.now() });
                    }
                }, 2000);
            }
            
            handleDeviceInfo(info) {
                this.deviceInfo = info;
                // ‚úÖ Forzar WebSocket (no WebRTC)
                info.supports_webrtc = false;
                this.displayDeviceInfo(info);
                this.createMixerConsole(info.channels);
                this.calculateEstimatedLatency();
            }
            
            setupEventListeners() {
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                });
            }
            
            async initAudioContext() {
                if (this.audioContext) return true;
                
                if (!this.deviceInfo) {
                    console.warn('[Audio] Esperando device_info...');
                    return false;
                }
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: this.deviceInfo.sample_rate
                    });
                    
                    await this.loadAudioWorklet();
                    this.calculateEstimatedLatency();
                    this.audioInitialized = true;
                    
                    return true;
                } catch (error) {
                    console.error('[Audio] Error:', error);
                    this.showWarning(`Error audio: ${error.message}`);
                    return false;
                }
            }
            
            async loadAudioWorklet() {
                try {
                    await this.audioContext.audioWorklet.addModule('/audio-processor.js');
                    this.audioWorkletReady = true;
                    console.log('[AudioWorklet] Cargado correctamente');
                } catch (error) {
                    console.error('[AudioWorklet] Error:', error);
                    this.audioWorkletReady = false;
                }
            }
            
            displayDeviceInfo(info) {
                const protocolBadge = info.supports_webrtc ? 
                    ' | ‚ö° WebRTC' : ' | üåê WebSocket';
                
                document.getElementById('device-info').textContent = 
                    `${info.name} | ${info.channels} CH | ${info.sample_rate} Hz${protocolBadge}`;
            }
            
            calculateEstimatedLatency() {
                if (!this.deviceInfo) return;
                
                const captureLatency = (this.deviceInfo.blocksize / this.deviceInfo.sample_rate * 1000);
                const jitterBuffer = this.deviceInfo.jitter_buffer_ms || 30;
                const processingLatency = 2;
                
                let networkLatency = 10;
                
                if (this.protocol === 'websocket') {
                    networkLatency = this.metrics.networkLatency || 15;
                }
                
                let contextLatency = 0;
                if (this.audioContext) {
                    contextLatency = (this.audioContext.baseLatency + this.audioContext.outputLatency) * 1000;
                }
                
                this.metrics.estimatedLatency = 
                    captureLatency + jitterBuffer + processingLatency + networkLatency + contextLatency;
            }
            
            createMixerConsole(numChannels) {
                const mixer = document.getElementById('mixer-console');
                mixer.innerHTML = '';
                
                for (let i = 0; i < numChannels; i++) {
                    const strip = document.createElement('div');
                    strip.className = 'channel-strip';
                    strip.innerHTML = `
                        <div class="channel-number">CH ${i + 1}</div>
                        
                        <button class="power-btn" data-channel="${i}">PWR</button>
                        
                        <div class="vu-meter">
                            <div class="vu-meter-fill" data-channel="${i}"></div>
                        </div>
                        
                        <div class="fader-container">
                            <label class="fader-label">VOL</label>
                            <input type="range" class="fader" data-channel="${i}"
                                   min="-60" max="12" value="0" step="1" orient="vertical">
                            <span class="fader-value">0dB</span>
                        </div>
                        
                        <div class="pan-container">
                            <label class="pan-label">PAN</label>
                            <input type="range" class="pan-control" data-channel="${i}"
                                   min="-100" max="100" value="0" step="1">
                            <span class="pan-value">C</span>
                        </div>
                    `;
                    
                    mixer.appendChild(strip);
                }
                
                document.querySelectorAll('.power-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const channel = parseInt(e.target.dataset.channel);
                        this.toggleChannel(channel, e.target);
                    });
                });
                
                document.querySelectorAll('.fader').forEach(fader => {
                    fader.addEventListener('input', (e) => {
                        const channel = parseInt(e.target.dataset.channel);
                        const db = parseFloat(e.target.value);
                        const gain = this.dbToGain(db);
                        
                        e.target.nextElementSibling.textContent = `${db > 0 ? '+' : ''}${db}dB`;
                        this.updateChannelGain(channel, gain);
                    });
                });
                
                document.querySelectorAll('.pan-control').forEach(pan => {
                    pan.addEventListener('input', (e) => {
                        const channel = parseInt(e.target.dataset.channel);
                        const panValue = parseFloat(e.target.value);
                        
                        let panText = panValue === 0 ? 'C' : 
                                     panValue < 0 ? `L${Math.abs(panValue)}` : 
                                     `R${panValue}`;
                        e.target.nextElementSibling.textContent = panText;
                        
                        this.updateChannelPan(channel, panValue);
                    });
                });
                
                document.getElementById('channel-count').textContent = `CHANNELS: ${numChannels}`;
            }
            
            async toggleChannel(channel, button) {
                console.log(`[App] toggleChannel(${channel}) INICIADO`);
                
                const strip = button.closest('.channel-strip');
                
                if (this.activeChannels.has(channel)) {
                    console.log(`[App] Desactivando canal ${channel}`);
                    this.activeChannels.delete(channel);
                    button.classList.remove('active');
                    strip.classList.remove('active');
                    
                    if (this.channelProcessors[channel]) {
                        this.channelProcessors[channel].panNode.disconnect();
                        this.channelProcessors[channel].gainNode.disconnect();
                        if (this.channelProcessors[channel].workletNode) {
                            this.channelProcessors[channel].workletNode.disconnect();
                        }
                        delete this.channelProcessors[channel];
                    }
                } else {
                    console.log(`[App] Activando canal ${channel}`);
                    this.activeChannels.add(channel);
                    button.classList.add('active');
                    strip.classList.add('active');
                    
                    if (!this.audioContext) {
                        console.log('[App] Iniciando WebSocket audio...');
                        const success = await this.initAudioContext();
                        if (!success) {
                            console.error('[App] Error iniciando WebSocket audio');
                            return;
                        }
                    }
                    this.createChannelProcessor(channel);
                }
                
                this.updateSubscription();
                
                document.getElementById('audio-status').textContent = 
                    `AUDIO: ${this.activeChannels.size} ACTIVE (${this.metrics.protocol})`;
            }
         
            createChannelProcessor(channel) {
                try {
                    if (!this.audioWorkletReady) {
                        this.createChannelProcessorFallback(channel);
                        return;
                    }
                    
                    const bufferSize = Math.max(3, Math.ceil(
                        ((this.deviceInfo.jitter_buffer_ms || 30) / 1000) * 
                        this.deviceInfo.sample_rate / 
                        this.deviceInfo.blocksize
                    ));
                    
                    const workletNode = new AudioWorkletNode(this.audioContext, 'audio-processor', {
                        processorOptions: { bufferSize }
                    });
                    
                    const gainNode = this.audioContext.createGain();
                    gainNode.gain.value = 1.0;
                    
                    const panNode = this.audioContext.createStereoPanner();
                    panNode.pan.value = 0;
                    
                    workletNode.connect(gainNode);
                    gainNode.connect(panNode);
                    panNode.connect(this.audioContext.destination);
                    
                    workletNode.port.onmessage = (event) => {
                        if (event.data.type === 'bufferHealth') {
                            this.metrics.bufferHealth = event.data.value;
                        }
                    };
                    
                    this.channelProcessors[channel] = {
                        workletNode,
                        gainNode,
                        panNode,
                        gain: 1.0,
                        pan: 0
                    };
                    
                } catch (error) {
                    console.error(`[Canal ${channel}] Error:`, error);
                    this.createChannelProcessorFallback(channel);
                }
            }
            
            createChannelProcessorFallback(channel) {
                const bufferSize = 2048;
                const processor = this.audioContext.createScriptProcessor(bufferSize, 1, 2);
                const gainNode = this.audioContext.createGain();
                gainNode.gain.value = 1.0;
                
                const panNode = this.audioContext.createStereoPanner();
                panNode.pan.value = 0;
                
                const jitterBuffer = [];
                const targetSize = Math.max(2, Math.ceil(
                    ((this.deviceInfo.jitter_buffer_ms || 30) / 1000) * 
                    this.deviceInfo.sample_rate / 
                    this.deviceInfo.blocksize
                ));
                
                processor.onaudioprocess = (e) => {
                    const outputL = e.outputBuffer.getChannelData(0);
                    const outputR = e.outputBuffer.getChannelData(1);
                    let outputIndex = 0;
                    
                    if (jitterBuffer.length < targetSize) {
                        outputL.fill(0);
                        outputR.fill(0);
                        return;
                    }
                    
                    const pan = this.channelProcessors[channel]?.pan || 0;
                    const gain = this.channelProcessors[channel]?.gain || 1.0;
                    
                    while (outputIndex < outputL.length && jitterBuffer.length > 0) {
                        const chunk = jitterBuffer.shift();
                        const copyLength = Math.min(chunk.length, outputL.length - outputIndex);
                        
                        for (let i = 0; i < copyLength; i++) {
                            const sample = chunk[i] * gain;
                            outputL[outputIndex + i] = sample * (1 - Math.max(0, pan));
                            outputR[outputIndex + i] = sample * (1 + Math.min(0, pan));
                        }
                        
                        outputIndex += copyLength;
                    }
                    
                    if (outputIndex < outputL.length) {
                        outputL.fill(0, outputIndex);
                        outputR.fill(0, outputIndex);
                    }
                    
                    this.metrics.bufferHealth = (jitterBuffer.length / targetSize) * 100;
                };
                
                processor.connect(gainNode);
                gainNode.connect(panNode);
                panNode.connect(this.audioContext.destination);
                
                this.channelProcessors[channel] = {
                    processor,
                    gainNode,
                    panNode,
                    jitterBuffer,
                    targetSize,
                    gain: 1.0,
                    pan: 0
                };
            }
            
            updateSubscription() {
                const channels = Array.from(this.activeChannels);
                const gains = {};
                
                channels.forEach(ch => {
                    gains[ch] = this.channelProcessors[ch]?.gain || 1.0;
                });
                
                if (this.socket?.connected) {
                    this.socket.emit('subscribe', { channels, gains });
                    console.log('[WebSocket] Suscripci√≥n actualizada:', channels);
                }
            }
            
            updateChannelGain(channel, gain) {
                if (this.channelProcessors[channel]) {
                    this.channelProcessors[channel].gain = gain;
                    this.channelProcessors[channel].gainNode.gain.value = gain;
                    
                    if (this.socket?.connected) {
                        this.socket.emit('update_gain', { channel, gain });
                    }
                }
            }
            
            updateChannelPan(channel, panValue) {
                if (this.channelProcessors[channel]) {
                    const normalizedPan = panValue / 100;
                    this.channelProcessors[channel].pan = normalizedPan;
                    this.channelProcessors[channel].panNode.pan.value = normalizedPan;
                }
            }
            
            handleAudioData(data) {
                const view = new DataView(data);
                const channel = view.getUint32(0, true);
                
                if (!this.activeChannels.has(channel)) return;
                
                const numSamples = (data.byteLength - 4) / 4;
                const audioData = new Float32Array(data, 4, numSamples);
                
                if (audioData.length === 0) return;
                
                const rms = Math.sqrt(audioData.reduce((sum, val) => sum + val * val, 0) / audioData.length);
                const db = 20 * Math.log10(Math.max(rms, 0.00001));
                const percentage = Math.max(0, Math.min(100, ((db + 60) / 60) * 100));
                
                const vuMeter = document.querySelector(`.vu-meter-fill[data-channel="${channel}"]`);
                if (vuMeter) {
                    vuMeter.style.height = `${percentage}%`;
                }
                
                const channelData = this.channelProcessors[channel];
                if (!channelData) return;
                
                if (channelData.workletNode) {
                    channelData.workletNode.port.postMessage({ type: 'audio', data: audioData });
                } else if (channelData.jitterBuffer) {
                    channelData.jitterBuffer.push(audioData);
                    if (channelData.jitterBuffer.length > channelData.targetSize * 5) {
                        channelData.jitterBuffer.shift();
                    }
                }
            }
            
            updateNetworkLatency(latency) {
                this.metrics.networkLatency = this.metrics.networkLatency * 0.8 + latency * 0.2;
                this.calculateEstimatedLatency();
            }
            
            startMetricsMonitoring() {
                setInterval(() => {
                    this.updateMetricsDisplay();
                }, 100);
            }
            
            updateMetricsDisplay() {
                this.calculateEstimatedLatency();
                
                const latencyEl = document.getElementById('latency');
                if (latencyEl) {
                    const latency = Math.round(this.metrics.estimatedLatency);
                    latencyEl.textContent = latency;
                    latencyEl.className = 'metric-value ' + 
                        (latency <= 15 ? '' : latency <= 30 ? 'warning' : 'bad');
                }
                
                const bufferEl = document.getElementById('buffer');
                if (bufferEl) {
                    const buffer = Math.round(this.metrics.bufferHealth);
                    bufferEl.textContent = buffer;
                    bufferEl.className = 'metric-value ' + 
                        (buffer >= 50 && buffer <= 150 ? '' : buffer > 150 ? 'warning' : 'bad');
                }
                
                const networkEl = document.getElementById('network');
                if (networkEl) {
                    const network = Math.round(this.metrics.networkLatency);
                    networkEl.textContent = network;
                    networkEl.className = 'metric-value ' + 
                        (network <= 10 ? '' : network <= 25 ? 'warning' : 'bad');
                }
                
                this.updateProtocolDisplay();
            }
            
            updateProtocolDisplay() {
                const protocolEl = document.getElementById('protocol');
                if (protocolEl) {
                    protocolEl.textContent = this.metrics.protocol;
                }
            }
            
            dbToGain(db) {
                return Math.pow(10, db / 20);
            }
            
            updateStatus(message, connected) {
                document.getElementById('status-text').textContent = message;
                const led = document.getElementById('status-led');
                
                if (connected) {
                    led.classList.add('active');
                } else {
                    led.classList.remove('active');
                }
            }
            
            showWarning(message) {
                const warningEl = document.getElementById('warning-message');
                if (warningEl) {
                    warningEl.textContent = `‚ö†Ô∏è ${message}`;
                    warningEl.style.display = 'block';
                    
                    setTimeout(() => {
                        warningEl.style.display = 'none';
                    }, 5000);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.audioMonitor = new AudioMonitor();
        });
    </script>

</body>
</html>