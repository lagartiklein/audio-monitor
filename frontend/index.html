
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Monitor - Ultra Low Latency</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ñê‚ñå AUDIO MONITOR ‚ñê‚ñå <span style="color: #f00; font-size: 0.6em;">OPTIMIZED v2.0</span></h1>
            <div id="device-info" class="device-info">INITIALIZING SYSTEM...</div>
            
            <div class="metrics">
                <div class="metric">
                    <span class="metric-label">LAT:</span>
                    <span id="latency" class="metric-value">--</span>
                    <span>ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">BUF:</span>
                    <span id="buffer" class="metric-value">--</span>
                    <span>%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">NET:</span>
                    <span id="network" class="metric-value">--</span>
                    <span>ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">SNR:</span>
                    <span id="snr" class="metric-value">--</span>
                    <span>dB</span>
                </div>
                <div class="metric">
                    <span class="metric-label">MODE:</span>
                    <span id="protocol" class="metric-value">OPT</span>
                </div>
            </div>
        </header>

        <div id="mixer-console" class="mixer-console"></div>
    </div>

    <div class="status-bar">
        <div class="status-indicator">
            <div id="status-led" class="status-led"></div>
            <span id="status-text">CONNECTING...</span>
        </div>
        <div id="channel-count">CHANNELS: 0</div>
        <div id="audio-status">AUDIO: INITIALIZING</div>
    </div>

    <div id="warning-message" class="warning-message"></div>

    <script>
        class AdaptiveRingBuffer {
            constructor(sampleRate, initialSizeMs = 10) {
                this.sampleRate = sampleRate;
                this.minSize = Math.floor(sampleRate * 0.008); // 8ms m√≠nimo
                this.maxSize = Math.floor(sampleRate * 0.021); // 21ms m√°ximo
                this.targetSize = Math.floor(sampleRate * (initialSizeMs / 1000));
                
                this.data = new Float32Array(this.maxSize * 2);
                this.writePos = 0;
                this.readPos = 0;
                this.available = 0;
                
                // M√©tricas para adaptaci√≥n
                this.underrunCount = 0;
                this.overrunCount = 0;
                this.lastAdjustTime = Date.now();
            }
            
            write(samples) {
                for (let i = 0; i < samples.length; i++) {
                    this.data[this.writePos] = samples[i];
                    this.writePos = (this.writePos + 1) % this.data.length;
                    
                    if (this.available >= this.data.length) {
                        this.readPos = (this.readPos + 1) % this.data.length;
                        this.overrunCount++;
                    } else {
                        this.available++;
                    }
                }
            }
            
            read() {
                if (this.available > 0) {
                    const sample = this.data[this.readPos];
                    this.readPos = (this.readPos + 1) % this.data.length;
                    this.available--;
                    return sample;
                }
                
                this.underrunCount++;
                return 0; // Silencio en underrun
            }
            
            // Interpolaci√≥n lineal para smooth playback
            readInterpolated(fractionalPosition) {
                if (this.available < 2) {
                    this.underrunCount++;
                    return 0;
                }
                
                const pos1 = this.readPos;
                const pos2 = (this.readPos + 1) % this.data.length;
                
                const sample1 = this.data[pos1];
                const sample2 = this.data[pos2];
                
                const frac = fractionalPosition % 1;
                return sample1 + (sample2 - sample1) * frac;
            }
            
            getHealthPercent() {
                return Math.round((this.available / this.targetSize) * 100);
            }
            
            adapt() {
                const now = Date.now();
                if (now - this.lastAdjustTime < 2000) return; // Ajustar cada 2s
                
                this.lastAdjustTime = now;
                
                // Si hay muchos underruns, aumentar buffer
                if (this.underrunCount > 10) {
                    this.targetSize = Math.min(this.targetSize + 64, this.maxSize);
                    console.log(`[Buffer] ‚¨ÜÔ∏è Aumentado a ${this.targetSize} samples (${(this.targetSize/this.sampleRate*1000).toFixed(1)}ms)`);
                }
                // Si est√° estable y el buffer es grande, reducir
                else if (this.underrunCount === 0 && this.overrunCount === 0 && this.targetSize > this.minSize) {
                    this.targetSize = Math.max(this.targetSize - 32, this.minSize);
                    console.log(`[Buffer] ‚¨áÔ∏è Reducido a ${this.targetSize} samples (${(this.targetSize/this.sampleRate*1000).toFixed(1)}ms)`);
                }
                
                this.underrunCount = 0;
                this.overrunCount = 0;
            }
        }

        class UltraLowLatencyAudioMonitor {
            constructor() {
                this.socket = null;
                this.audioContext = null;
                this.deviceInfo = null;
                this.activeChannels = new Set();
                this.channelProcessors = {};
                
                // üéØ MEJORA 1: Buffer adaptativo por canal
                this.buffers = {};
                
                // üéØ MEJORA 2: Ganancia aplicada en cliente (no en servidor)
                this.channelGains = {};
                
                // üéØ MEJORA 3: Configuraci√≥n de panorama
                this.channelPans = {};
                
                // üéØ MEJORA 4: Dithering para mejor calidad
                this.ditherEnabled = true;
                
                this.metrics = {
                    networkLatency: 0,
                    bufferHealth: 100,
                    estimatedLatency: 0,
                    audioLatency: 0,
                    dropped: 0,
                    snr: 0
                };
                
                this.connected = false;
                this.audioInitialized = false;
                this.init();
            }

            async init() {
                console.log('[üöÄ OPTIMIZED MODE v2.0 - QUALITY ENHANCED]');
                this.updateStatus('CONNECTING...', false);
                await this.connectWebSocket();
                this.startMetricsMonitoring();
            }
            
            async connectWebSocket() {
                console.log('[WebSocket] Conectando...');
                
                this.socket = io({
                    transports: ['websocket'],
                    upgrade: false,
                    reconnection: true,
                    reconnectionDelay: 500,
                    reconnectionAttempts: 10,
                    perMessageDeflate: false,
                    rememberUpgrade: true,
                    timeout: 5000
                });
                
                this.socket.on('connect', () => {
                    console.log('[Socket] ‚úÖ Conectado');
                    this.updateStatus('CONNECTED', true);
                    this.connected = true;
                    document.getElementById('audio-status').textContent = 'AUDIO: READY (OPTIMIZED)';
                    
                    if (this.activeChannels.size > 0) {
                        setTimeout(() => this.updateSubscription(), 100);
                    }
                });
                
                this.socket.on('disconnect', (reason) => {
                    console.log('[Socket] Desconectado:', reason);
                    this.updateStatus('DISCONNECTED', false);
                    this.connected = false;
                });
                
                this.socket.on('device_info', (info) => {
                    this.handleDeviceInfo(info);
                });
                
                this.socket.on('audio_batch', (data) => {
                    this.handleAudioBatch(data);
                });
                
                this.socket.on('pong', (data) => {
                    const latency = Date.now() - data.client_timestamp;
                    this.updateNetworkLatency(latency);
                });
                
                setInterval(() => {
                    if (this.socket?.connected) {
                        this.socket.emit('ping', { timestamp: Date.now() });
                    }
                }, 2000);
            }
            
            handleDeviceInfo(info) {
                this.deviceInfo = info;
                console.log('[Device]', info);
                this.displayDeviceInfo(info);
                this.createMixerConsole(info.channels);
                this.calculateEstimatedLatency();
            }
            
            async initAudioContext() {
                if (this.audioContext) return true;
                if (!this.deviceInfo) return false;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: this.deviceInfo.sample_rate
                    });
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    this.calculateEstimatedLatency();
                    this.audioInitialized = true;
                    
                    console.log(`[Audio] ‚úÖ Modo: ScriptProcessor (Optimizado)`);
                    console.log(`[Audio] ‚úÖ Sample Rate: ${this.audioContext.sampleRate} Hz`);
                    console.log(`[Audio] ‚úÖ Latencia base: ${(this.audioContext.baseLatency * 1000).toFixed(2)}ms`);
                    console.log(`[Audio] üéØ Buffer adaptativo: 8-21ms din√°mico`);
                    
                    return true;
                } catch (error) {
                    console.error('[Audio] Error:', error);
                    return false;
                }
            }
            
            displayDeviceInfo(info) {
                document.getElementById('device-info').textContent = 
                    `${info.name} | ${info.channels} CH | ${info.sample_rate} Hz | Optimized Mode v2.0`;
            }
            
            calculateEstimatedLatency() {
                if (!this.deviceInfo) return;
                
                const captureLatency = (this.deviceInfo.blocksize / this.deviceInfo.sample_rate * 1000);
                const networkLatency = this.metrics.networkLatency || 3;
                const processingLatency = 0.3; // Optimizado
                
                // Buffer adaptativo promedio (calculado din√°micamente)
                let avgBufferLatency = 10; // Default 10ms
                if (Object.keys(this.buffers).length > 0) {
                    let totalLatency = 0;
                    for (const ch in this.buffers) {
                        const buf = this.buffers[ch];
                        totalLatency += (buf.targetSize / this.deviceInfo.sample_rate * 1000);
                    }
                    avgBufferLatency = totalLatency / Object.keys(this.buffers).length;
                }
                
                let contextLatency = 0;
                if (this.audioContext) {
                    contextLatency = (this.audioContext.baseLatency || 0) * 1000;
                }
                
                this.metrics.estimatedLatency = 
                    captureLatency + networkLatency + processingLatency + avgBufferLatency + contextLatency;
            }
            
            createMixerConsole(numChannels) {
                const mixer = document.getElementById('mixer-console');
                mixer.innerHTML = '';

                // Crear filas de canales (8 canales por fila)
                const rows = Math.ceil(numChannels / 8);
                for (let row = 0; row < rows; row++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'channel-row';

                    const startCh = row * 8;
                    const endCh = Math.min(startCh + 8, numChannels);

                    for (let i = startCh; i < endCh; i++) {
                        const strip = document.createElement('div');
                        strip.className = 'channel-strip';
                        strip.innerHTML = `
                            <!-- CABECERA DEL CANAL -->
                            <div class="strip-header">
                                <div class="channel-number">CH ${i + 1}</div>
                                <button class="power-btn" data-channel="${i}">PWR</button>
                            </div>

                            <!-- VU METER + FADER JUNTOS -->
                            <div class="vu-fader-section">
                                <div class="vu-meter">
                                    <div class="vu-meter-scale">
                                        <div class="vu-tick" style="top: 0%">0</div>
                                        <div class="vu-tick" style="top: 20%">-12</div>
                                        <div class="vu-tick" style="top: 40%">-24</div>
                                        <div class="vu-tick" style="top: 60%">-36</div>
                                        <div class="vu-tick" style="top: 80%">-48</div>
                                    </div>
                                    <div class="vu-meter-fill" data-channel="${i}"></div>
                                    <div class="vu-meter-peak" data-channel="${i}"></div>
                                </div>
                                <div class="fader-section">
                                    <div class="fader-wrapper">
                                        <div class="fader-track"></div>
                                        <input type="range" class="fader" data-channel="${i}"
                                               min="-60" max="12" value="0" step="0.5" orient="vertical">
                                        <div class="fader-thumb"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- DISPLAY dB Y CONTROLES INFERIORES -->
                            <div class="bottom-section">
                                <div class="db-display" data-channel="${i}">0.0dB</div>

                                <div class="pan-control-section">
                                    <label class="pan-label">PAN</label>
                                    <div class="pan-knob-wrapper">
                                        <div class="pan-knob" data-channel="${i}">
                                            <div class="knob-mark"></div>
                                        </div>
                                        <input type="range" class="pan-input" data-channel="${i}"
                                               min="-100" max="100" value="0" step="2">
                                    </div>
                                    <div class="pan-value" data-channel="${i}">C</div>
                                </div>
                            </div>
                        `;
                        rowDiv.appendChild(strip);
                    }

                    mixer.appendChild(rowDiv);
                }

                // Inicializar controles
                this.initChannelControls();

                document.getElementById('channel-count').textContent = `CHANNELS: ${numChannels}`;
            }
            
            initChannelControls() {
                // Bot√≥n Power
                document.querySelectorAll('.power-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const channel = parseInt(e.target.dataset.channel);
                        this.toggleChannel(channel, e.target);
                    });
                });
                
                // Faders
                document.querySelectorAll('.fader').forEach(fader => {
                    fader.addEventListener('input', (e) => {
                        const channel = parseInt(e.target.dataset.channel);
                        const db = parseFloat(e.target.value);
                        this.updateFaderUI(channel, db);
                        this.updateChannelGain(channel, db);
                    });
                    
                    // Inicializar posici√≥n del thumb
                    const channel = parseInt(fader.dataset.channel);
                    this.updateFaderUI(channel, parseFloat(fader.value));
                });
                
                // Knobs de panorama
                document.querySelectorAll('.pan-input').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const channel = parseInt(e.target.dataset.channel);
                        const panValue = parseFloat(e.target.value);
                        this.updatePanUI(channel, panValue);
                        this.updateChannelPan(channel, panValue);
                    });
                    
                    // Inicializar knob
                    const channel = parseInt(input.dataset.channel);
                    this.updatePanUI(channel, parseFloat(input.value));
                });
                
                // Knobs t√°ctiles (drag)
                document.querySelectorAll('.pan-knob').forEach(knob => {
                    const channel = parseInt(knob.dataset.channel);
                    const input = knob.parentElement.querySelector('.pan-input');
                    
                    let isDragging = false;
                    let startY = 0;
                    let startValue = 0;
                    
                    knob.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        startY = e.clientY;
                        startValue = parseFloat(input.value);
                        e.preventDefault();
                    });
                    
                    knob.addEventListener('touchstart', (e) => {
                        isDragging = true;
                        startY = e.touches[0].clientY;
                        startValue = parseFloat(input.value);
                        e.preventDefault();
                    });
                    
                    const handleMove = (clientY) => {
                        if (!isDragging) return;
                        
                        const deltaY = startY - clientY;
                        const sensitivity = 0.5;
                        let newValue = startValue + (deltaY * sensitivity);
                        
                        // Limitar entre -100 y 100
                        newValue = Math.max(-100, Math.min(100, newValue));
                        
                        // Actualizar input y UI
                        input.value = newValue;
                        this.updatePanUI(channel, newValue);
                        this.updateChannelPan(channel, newValue);
                    };
                    
                    document.addEventListener('mousemove', (e) => handleMove(e.clientY));
                    document.addEventListener('touchmove', (e) => {
                        if (e.touches.length > 0) {
                            handleMove(e.touches[0].clientY);
                        }
                    });
                    
                    document.addEventListener('mouseup', () => isDragging = false);
                    document.addEventListener('touchend', () => isDragging = false);
                });
            }
            
            updateFaderUI(channel, db) {
                // Actualizar display dB
                const dbDisplay = document.querySelector(`.db-display[data-channel="${channel}"]`);
                if (dbDisplay) {
                    dbDisplay.textContent = `${db >= 0 ? '+' : ''}${db.toFixed(1)}dB`;
                }
                
                // Actualizar posici√≥n del thumb
                const fader = document.querySelector(`.fader[data-channel="${channel}"]`);
                const thumb = fader?.parentElement.querySelector('.fader-thumb');
                if (fader && thumb) {
                    const min = parseFloat(fader.min);
                    const max = parseFloat(fader.max);
                    const range = max - min;
                    const percentage = ((db - min) / range) * 100;
                    
                    thumb.style.bottom = `${percentage}%`;
                }
            }
            
            updatePanUI(channel, panValue) {
                // Actualizar display de panorama
                const panDisplay = document.querySelector(`.pan-value[data-channel="${channel}"]`);
                if (panDisplay) {
                    panDisplay.textContent = panValue === 0 ? 'C' : 
                                           panValue < 0 ? `L${Math.abs(panValue)}` : `R${panValue}`;
                }
                
                // Actualizar rotaci√≥n del knob
                const knob = document.querySelector(`.pan-knob[data-channel="${channel}"]`);
                if (knob) {
                    // -100 a 100 se convierte en -150¬∞ a 150¬∞
                    const rotation = (panValue / 100) * 150;
                    knob.style.transform = `rotate(${rotation}deg)`;
                }
            }
            
            async toggleChannel(channel, button) {
                const strip = button.closest('.channel-strip');
                
                if (this.activeChannels.has(channel)) {
                    console.log(`[Canal ${channel}] Desactivando...`);
                    this.activeChannels.delete(channel);
                    button.classList.remove('active');
                    strip.classList.remove('active');
                    
                    if (this.channelProcessors[channel]) {
                        try {
                            this.channelProcessors[channel].scriptNode.disconnect();
                            this.channelProcessors[channel].gainNode.disconnect();
                        } catch (e) {
                            console.warn(`[Canal ${channel}] Error desconectando:`, e);
                        }
                        delete this.channelProcessors[channel];
                        delete this.buffers[channel];
                        delete this.channelGains[channel];
                        delete this.channelPans[channel];
                    }
                } else {
                    console.log(`[Canal ${channel}] Activando...`);
                    this.activeChannels.add(channel);
                    button.classList.add('active');
                    strip.classList.add('active');
                    
                    if (!this.audioContext) {
                        console.log('[Audio] Iniciando AudioContext...');
                        const success = await this.initAudioContext();
                        if (!success) {
                            console.error('[Audio] ‚ùå No se pudo iniciar AudioContext');
                            this.activeChannels.delete(channel);
                            button.classList.remove('active');
                            strip.classList.remove('active');
                            alert('Error: No se pudo iniciar el audio.');
                            return;
                        }
                    }
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    this.createChannelProcessor(channel);
                }
                
                this.updateSubscription();
                document.getElementById('audio-status').textContent = 
                    `AUDIO: ${this.activeChannels.size} ACTIVE [OPT]`;
            }
            
            createChannelProcessor(channel) {
                try {
                    console.log(`[Canal ${channel}] üéØ Creando procesador optimizado...`);
                    
                    // üéØ MEJORA 1: Buffer adaptativo
                    this.buffers[channel] = new AdaptiveRingBuffer(
                        this.audioContext.sampleRate,
                        10 // 10ms inicial
                    );
                    
                    // üéØ MEJORA 2: Ganancia en cliente (no en servidor)
                    this.channelGains[channel] = 1.0; // Linear gain (0dB)
                    
                    // üéØ MEJORA 3: Panorama inicial
                    this.channelPans[channel] = 0; // Centro
                    
                    const scriptNode = this.audioContext.createScriptProcessor(256, 1, 2);
                    
                    // Contadores para SNR
                    let signalPower = 0;
                    let noisePower = 0;
                    let sampleCount = 0;
                    
                    scriptNode.onaudioprocess = (audioProcessingEvent) => {
                        const outputL = audioProcessingEvent.outputBuffer.getChannelData(0);
                        const outputR = audioProcessingEvent.outputBuffer.getChannelData(1);
                        const bufferLength = outputL.length;
                        
                        const buffer = this.buffers[channel];
                        
                        if (!buffer) return;
                        
                        // üéØ Adaptaci√≥n din√°mica del buffer
                        buffer.adapt();
                        
                        const pan = this.channelPans[channel] || 0;
                        const gain = this.channelGains[channel] || 1.0;
                        
                        // Calcular gains de panorama (Constant Power)
                        const panValue = pan / 100; // Convertir de -100..100 a -1..1
                        const panRad = ((panValue + 1) * Math.PI) / 4; // -1..1 -> 0..œÄ/2
                        const gainL = Math.cos(panRad) * gain;
                        const gainR = Math.sin(panRad) * gain;
                        
                        for (let i = 0; i < bufferLength; i++) {
                            let sample = 0;
                            
                            if (buffer.available > 0) {
                                // üéØ MEJORA 3: Interpolaci√≥n lineal
                                sample = buffer.readInterpolated(0);
                                buffer.read(); // Avanzar posici√≥n
                            }
                            
                            // üéØ MEJORA 3: TPDF Dithering
                            if (this.ditherEnabled && sample !== 0) {
                                const ditherAmount = 1.0 / 32768; // 16-bit equiv
                                const dither = (Math.random() + Math.random() - 1) * ditherAmount;
                                sample += dither;
                            }
                            
                            // Calcular SNR
                            signalPower += sample * sample;
                            sampleCount++;
                            
                            // Aplicar ganancia y panorama
                            outputL[i] = sample * gainL;
                            outputR[i] = sample * gainR;
                        }
                        
                        // Actualizar SNR cada ~1 segundo
                        if (sampleCount > this.audioContext.sampleRate) {
                            const avgSignal = signalPower / sampleCount;
                            const estimatedNoise = 1e-8; // Ruido de cuantizaci√≥n
                            this.metrics.snr = 10 * Math.log10(avgSignal / estimatedNoise);
                            signalPower = 0;
                            sampleCount = 0;
                        }
                    };
                    
                    // Crear nodos de audio
                    const gainNode = this.audioContext.createGain();
                    gainNode.gain.value = 1.0;
                    
                    // Conectar
                    scriptNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    this.channelProcessors[channel] = {
                        scriptNode,
                        gainNode
                    };
                    
                    console.log(`[Canal ${channel}] ‚úÖ Optimizado: Buffer adaptativo 8-21ms`);
                    
                } catch (error) {
                    console.error(`[Canal ${channel}] ‚ùå Error:`, error);
                    alert(`Error: ${error.message}`);
                }
            }
            
            updateSubscription() {
                const channels = Array.from(this.activeChannels);
                
                // üéØ NO enviar gains al servidor (procesamos en cliente)
                if (this.socket?.connected) {
                    this.socket.emit('subscribe', { channels, gains: {} });
                    console.log('[Subscribe]', channels, '(sin gains del servidor)');
                }
            }
            
            updateChannelGain(channel, db) {
                // üéØ MEJORA 2: Ganancia aplicada SOLO en cliente
                const gain = this.dbToGain(db);
                this.channelGains[channel] = gain;
                console.log(`[Canal ${channel}] Gain: ${db}dB (${gain.toFixed(3)} linear)`);
            }
            
            updateChannelPan(channel, panValue) {
                // Almacenar valor de panorama
                this.channelPans[channel] = panValue;
                console.log(`[Canal ${channel}] Pan: ${panValue}`);
            }
            
            handleAudioBatch(data) {
                try {
                    const view = new DataView(data);
                    let offset = 0;
                    
                    const numChannels = view.getUint32(offset, true);
                    offset += 4;
                    
                    for (let i = 0; i < numChannels; i++) {
                        const channel = view.getUint32(offset, true);
                        offset += 4;
                        
                        const dataLength = view.getUint32(offset, true);
                        offset += 4;
                        
                        if (!this.activeChannels.has(channel)) {
                            offset += dataLength;
                            continue;
                        }
                        
                        const numSamples = dataLength / 4;
                        const audioData = new Float32Array(data, offset, numSamples);
                        offset += dataLength;
                        
                        // VU Meter (cada 2 frames para rendimiento)
                        if (i % 2 === 0) {
                            const rms = Math.sqrt(
                                audioData.reduce((sum, val) => sum + val * val, 0) / audioData.length
                            );
                            const db = 20 * Math.log10(Math.max(rms, 0.00001));
                            const percentage = Math.max(0, Math.min(100, ((db + 60) / 60) * 100));
                            
                            const vuMeter = document.querySelector(`.vu-meter-fill[data-channel="${channel}"]`);
                            if (vuMeter) {
                                vuMeter.style.height = `${percentage}%`;
                            }
                            
                            // Peak hold
                            const vuPeak = document.querySelector(`.vu-meter-peak[data-channel="${channel}"]`);
                            if (vuPeak) {
                                if (percentage > parseFloat(vuPeak.style.height || 0)) {
                                    vuPeak.style.height = `${percentage}%`;
                                    vuPeak.style.opacity = '1';
                                    
                                    // Reset peak despu√©s de 1 segundo
                                    clearTimeout(vuPeak._peakTimeout);
                                    vuPeak._peakTimeout = setTimeout(() => {
                                        vuPeak.style.opacity = '0';
                                    }, 1000);
                                }
                            }
                        }
                        
                        // üéØ Escribir en buffer adaptativo
                        const buffer = this.buffers[channel];
                        if (buffer) {
                            buffer.write(audioData);
                        }
                    }
                } catch (error) {
                    console.error('[AudioBatch] Error:', error);
                    this.metrics.dropped++;
                }
            }
            
            updateNetworkLatency(latency) {
                this.metrics.networkLatency = this.metrics.networkLatency * 0.7 + latency * 0.3;
                this.calculateEstimatedLatency();
            }
            
            startMetricsMonitoring() {
                setInterval(() => {
                    this.updateMetricsDisplay();
                }, 100);
            }
            
            updateMetricsDisplay() {
                this.calculateEstimatedLatency();
                
                const latencyEl = document.getElementById('latency');
                if (latencyEl) {
                    const latency = Math.round(this.metrics.estimatedLatency);
                    latencyEl.textContent = latency;
                    latencyEl.className = 'metric-value ' + 
                        (latency <= 12 ? '' : latency <= 20 ? 'warning' : 'bad');
                }
                
                const bufferEl = document.getElementById('buffer');
                if (bufferEl) {
                    let avgHealth = 0;
                    let count = 0;
                    
                    for (const channel in this.buffers) {
                        avgHealth += this.buffers[channel].getHealthPercent();
                        count++;
                    }
                    
                    const health = count > 0 ? Math.round(avgHealth / count) : 0;
                    bufferEl.textContent = health;
                    bufferEl.className = 'metric-value ' + 
                        (health >= 40 ? '' : health >= 20 ? 'warning' : 'bad');
                }
                
                const networkEl = document.getElementById('network');
                if (networkEl) {
                    const network = Math.round(this.metrics.networkLatency);
                    networkEl.textContent = network;
                    networkEl.className = 'metric-value ' + 
                        (network <= 5 ? '' : network <= 15 ? 'warning' : 'bad');
                }
                
                const snrEl = document.getElementById('snr');
                if (snrEl) {
                    const snr = Math.round(this.metrics.snr);
                    snrEl.textContent = snr > 0 ? snr : '--';
                    snrEl.className = 'metric-value ' + 
                        (snr >= 60 ? '' : snr >= 40 ? 'warning' : 'bad');
                }
                
                const protocolEl = document.getElementById('protocol');
                if (protocolEl) {
                    protocolEl.textContent = 'OPT';
                }
            }
            
            dbToGain(db) {
                return Math.pow(10, db / 20);
            }
            
            updateStatus(message, connected) {
                document.getElementById('status-text').textContent = message;
                const led = document.getElementById('status-led');
                
                if (connected) {
                    led.classList.add('active');
                } else {
                    led.classList.remove('active');
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.audioMonitor = new UltraLowLatencyAudioMonitor();
        });
    </script>
</body>
</html>
