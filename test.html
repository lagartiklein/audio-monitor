
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test WebRTC Audio Debug</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
        }
        .log {
            background: #000;
            border: 1px solid #00ff00;
            padding: 10px;
            margin: 10px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        .success { color: #00ff00; }
        .error { color: #ff0000; }
        .warning { color: #ff9800; }
        .info { color: #2196F3; }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        button:hover {
            background: #00cc00;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #666;
        }
        .status.connected {
            border-color: #00ff00;
        }
        .status.error {
            border-color: #ff0000;
        }
    </style>
</head>
<body>
    <h1>üîç WebRTC Audio Debug Tool</h1>
    
    <div class="status" id="status">
        <strong>Status:</strong> <span id="status-text">Disconnected</span>
    </div>
    
    <div>
        <button onclick="testWebSocket()">1. Test WebSocket Connection</button>
        <button onclick="testWebRTC()">2. Test WebRTC Connection</button>
        <button onclick="subscribeChannel()">3. Subscribe Channel 0</button>
        <button onclick="checkAudio()">4. Check Audio Playback</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>
    
    <h2>Debug Log:</h2>
    <div id="log" class="log"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        let socket = null;
        let webrtcPc = null;
        let audioContext = null;
        let deviceInfo = null;
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            const line = document.createElement('div');
            line.className = type;
            line.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(line);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }
        
        function updateStatus(text, connected = false) {
            const statusDiv = document.getElementById('status');
            const statusText = document.getElementById('status-text');
            statusText.textContent = text;
            statusDiv.className = connected ? 'status connected' : 'status error';
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
            log('Log cleared', 'info');
        }
        
        // ========================================
        // 1. Test WebSocket
        // ========================================
        function testWebSocket() {
            log('üîå Testing WebSocket connection...', 'info');
            
            socket = io({
                transports: ['websocket'],
                upgrade: false
            });
            
            socket.on('connect', () => {
                log('‚úÖ WebSocket connected! Session ID: ' + socket.id, 'success');
                updateStatus('WebSocket Connected', true);
            });
            
            socket.on('device_info', (info) => {
                deviceInfo = info;
                log('‚úÖ Device info received:', 'success');
                log(`   - Name: ${info.name}`, 'info');
                log(`   - Channels: ${info.channels}`, 'info');
                log(`   - Sample Rate: ${info.sample_rate} Hz`, 'info');
                log(`   - WebRTC Supported: ${info.supports_webrtc}`, 'info');
            });
            
            socket.on('disconnect', () => {
                log('‚ùå WebSocket disconnected', 'error');
                updateStatus('Disconnected', false);
            });
            
            socket.on('webrtc_answer', (data) => {
                log('üì® WebRTC answer received', 'success');
            });
            
            socket.on('webrtc_subscribed', (data) => {
                log(`‚úÖ WebRTC subscription confirmed for ${data.channels.length} channels`, 'success');
            });
            
            socket.on('webrtc_error', (data) => {
                log(`‚ùå WebRTC error: ${data.error}`, 'error');
            });
        }
        
        // ========================================
        // 2. Test WebRTC
        // ========================================
        async function testWebRTC() {
            if (!socket || !socket.connected) {
                log('‚ùå ERROR: WebSocket must be connected first!', 'error');
                return;
            }
            
            log('üåê Testing WebRTC connection...', 'info');
            
            try {
                // Crear AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    latencyHint: 'interactive'
                });
                log('‚úÖ AudioContext created: ' + audioContext.sampleRate + ' Hz', 'success');
                
                // Crear PeerConnection
                const config = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                };
                
                webrtcPc = new RTCPeerConnection(config);
                log('‚úÖ RTCPeerConnection created', 'success');
                
                // Event handlers
                webrtcPc.onicecandidate = (event) => {
                    if (event.candidate) {
                        log('üì° Sending ICE candidate', 'info');
                        socket.emit('webrtc_ice_candidate', {
                            candidate: event.candidate
                        });
                    } else {
                        log('‚úÖ ICE gathering complete', 'success');
                    }
                };
                
                webrtcPc.oniceconnectionstatechange = () => {
                    log(`üîó ICE Connection State: ${webrtcPc.iceConnectionState}`, 'info');
                    if (webrtcPc.iceConnectionState === 'connected') {
                        log('‚úÖ ICE CONNECTED!', 'success');
                    }
                };
                
                webrtcPc.onconnectionstatechange = () => {
                    log(`üîó Connection State: ${webrtcPc.connectionState}`, 'info');
                    if (webrtcPc.connectionState === 'connected') {
                        log('‚úÖ WebRTC CONNECTED!', 'success');
                        updateStatus('WebRTC Connected', true);
                    }
                };
                
                webrtcPc.ontrack = (event) => {
                    log('üéµ AUDIO TRACK RECEIVED!', 'success');
                    log(`   - Kind: ${event.track.kind}`, 'info');
                    log(`   - Ready State: ${event.track.readyState}`, 'info');
                    log(`   - Streams: ${event.streams.length}`, 'info');
                    
                    if (event.track.kind === 'audio' && event.streams[0]) {
                        // Conectar audio
                        const stream = event.streams[0];
                        const source = audioContext.createMediaStreamSource(stream);
                        const gainNode = audioContext.createGain();
                        gainNode.gain.value = 1.0;
                        
                        source.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        log('‚úÖ Audio connected to speakers!', 'success');
                        
                        // Tambi√©n crear elemento audio para debug
                        const audioEl = document.createElement('audio');
                        audioEl.autoplay = true;
                        audioEl.srcObject = stream;
                        audioEl.volume = 1.0;
                        document.body.appendChild(audioEl);
                        
                        log('‚úÖ Audio element created and playing', 'success');
                    }
                };
                
                // Crear oferta
                const offer = await webrtcPc.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: false
                });
                
                await webrtcPc.setLocalDescription(offer);
                log('‚úÖ Local description set', 'success');
                
                // Enviar oferta al servidor
                socket.emit('webrtc_offer', {
                    sdp: offer.sdp,
                    clientId: socket.id
                });
                log('üì§ WebRTC offer sent to server', 'info');
                
                // Esperar respuesta
                socket.once('webrtc_answer', async (data) => {
                    try {
                        await webrtcPc.setRemoteDescription({
                            type: 'answer',
                            sdp: data.sdp
                        });
                        log('‚úÖ Remote description set', 'success');
                    } catch (error) {
                        log(`‚ùå Error setting remote description: ${error.message}`, 'error');
                    }
                });
                
            } catch (error) {
                log(`‚ùå ERROR: ${error.message}`, 'error');
                console.error(error);
            }
        }
        
        // ========================================
        // 3. Subscribe to Channel
        // ========================================
        function subscribeChannel() {
            if (!socket || !socket.connected) {
                log('‚ùå ERROR: WebSocket not connected!', 'error');
                return;
            }
            
            log('üìù Subscribing to channel 0 via WebSocket...', 'info');
            
            // Enviar suscripci√≥n via WebSocket (el fix)
            socket.emit('webrtc_subscribe', {
                channels: [0],
                gains: { 0: 1.0 },
                clientId: socket.id
            });
            
            log('üì§ Subscription request sent', 'success');
            log('‚è≥ Waiting for confirmation...', 'info');
        }
        
        // ========================================
        // 4. Check Audio
        // ========================================
        function checkAudio() {
            log('üîä Checking audio playback status...', 'info');
            
            if (!audioContext) {
                log('‚ùå No AudioContext created', 'error');
                return;
            }
            
            log(`   - AudioContext state: ${audioContext.state}`, 'info');
            log(`   - Sample rate: ${audioContext.sampleRate} Hz`, 'info');
            log(`   - Base latency: ${(audioContext.baseLatency * 1000).toFixed(2)} ms`, 'info');
            log(`   - Output latency: ${(audioContext.outputLatency * 1000).toFixed(2)} ms`, 'info');
            
            if (audioContext.state === 'suspended') {
                log('‚ö†Ô∏è  AudioContext suspended, resuming...', 'warning');
                audioContext.resume().then(() => {
                    log('‚úÖ AudioContext resumed', 'success');
                });
            } else if (audioContext.state === 'running') {
                log('‚úÖ AudioContext is running', 'success');
            }
            
            if (webrtcPc) {
                log(`   - WebRTC connection: ${webrtcPc.connectionState}`, 'info');
                log(`   - ICE connection: ${webrtcPc.iceConnectionState}`, 'info');
                
                // Verificar tracks
                const receivers = webrtcPc.getReceivers();
                log(`   - Receivers: ${receivers.length}`, 'info');
                receivers.forEach((receiver, i) => {
                    const track = receiver.track;
                    log(`     [${i}] ${track.kind} - ${track.readyState} - ${track.enabled ? 'enabled' : 'disabled'}`, 'info');
                });
            }
            
            // Verificar si hay alg√∫n audio element
            const audioElements = document.querySelectorAll('audio');
            log(`   - Audio elements: ${audioElements.length}`, 'info');
            audioElements.forEach((audio, i) => {
                log(`     [${i}] paused: ${audio.paused}, volume: ${audio.volume}`, 'info');
            });
        }
        
        // Auto-start
        log('üöÄ WebRTC Audio Debug Tool Ready', 'success');
        log('üìã Follow steps 1-4 to diagnose connection', 'info');
    </script>
</body>
</html>